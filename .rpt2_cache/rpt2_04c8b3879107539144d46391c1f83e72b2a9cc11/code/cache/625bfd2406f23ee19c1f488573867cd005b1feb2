{"code":"import * as tslib_1 from \"tslib\";\r\nimport React from 'react';\r\nimport Dropdown from './components/Dropdown';\r\nimport Loader from './components/Loader';\r\nimport vis from 'vis';\r\nimport { setTimeout } from 'timers';\r\nimport Get_HardCoded_Refs from './JSON_MockUp_Sample';\r\nimport { getCSSProps } from './ThemeCSS';\r\nimport widgetconfig from './widgetconfig.json';\r\nimport ToggleBarItems from './components/ToggleBarItems';\r\nimport TabLinks from './components/TabLinks';\r\nimport Tabs from './components/Tabs';\r\nimport { ToggleBarItemsContext, LoaderContext, DropdownContext, TabLinksContext, TabsContext } from './context';\r\nvar Widget = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Widget, _super);\r\n    function Widget() {\r\n        /**\r\n         * dropdownIsCollapsed: boolean for dropdown toggle\r\n         * dropdownCurHeight: holds dropdown height value change\r\n         * activeTabName: this and activeTabLinkName are mainly used for navigating history (going back in time)\r\n         * historyExists: boolean to display 'back button' if true and hide if otherwise\r\n         * isViewedWithMobile: boolean to check what device app is running on (hides 'star button' if true, displays if false)\r\n         * tabLinksWrapperheight: a constant which will be needed in computing dropdown height and also loader wrapper height in Dropdown.tsx\r\n         * dropdown: child element of Widget\r\n         * activeTabLink: tab link/button\r\n         * activeTab: active tab/dropdown for either of the three togglable tabs\r\n         * history: An array of state objects; will hold the different state changes in order to enable and set state going back in time\r\n         */\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.state = {\r\n            dropdownIsCollapsed: true,\r\n            dropdownCurHeight: 0,\r\n            refID: '@powerofgod/17t8kcjuw',\r\n            activeTabName: 'required-tab',\r\n            activeTabLinkName: 'required-tab-link',\r\n            historyExists: false,\r\n            refIsLoading: true,\r\n            payload: {\r\n                data: {\r\n                    title: '',\r\n                    authors: [''],\r\n                    url: ''\r\n                },\r\n                id: '',\r\n                refs: [{}]\r\n            },\r\n            errOccurred: false,\r\n            errMsg: '',\r\n            graphNodeIsHovered: false,\r\n            graphNodeIsActive: false,\r\n            tooltipIsActive: false\r\n        };\r\n        _this.tabLinksWrapperheight = 48;\r\n        _this.graph = {\r\n            nodes: [],\r\n            edges: []\r\n        };\r\n        _this.isViewedWithMobile = false;\r\n        _this.child_refs = {\r\n            dropdown: React.createRef(),\r\n            activeTabLink: React.createRef(),\r\n            activeTab: React.createRef(),\r\n            requiredTab: React.createRef(),\r\n            recommendedTab: React.createRef(),\r\n            graphTab: React.createRef(),\r\n            graph: React.createRef(),\r\n            refItemWrapper: React.createRef(),\r\n            graphTooltip: React.createRef(),\r\n            refIDInputEl: React.createRef()\r\n        };\r\n        _this.widget = React.createRef();\r\n        _this.serverHostURL = /localhost/.test(window.location.href) ?\r\n            'localhost:1323' : widgetconfig.lemmaChainServerHost;\r\n        //copy initial/first state object and set at index 0 of history\r\n        _this.history = [];\r\n        _this.cssProps = getCSSProps();\r\n        _this.handleDropdownToggle = function (e) {\r\n            if (e.target.className.match('ref-identifier'))\r\n                _this.setState({ tooltipIsActive: !_this.state.tooltipIsActive });\r\n            else {\r\n                _this.setState(function (prevState) {\r\n                    var dropdownIsCollapsed = prevState.dropdownIsCollapsed, dropdownNewHeight = _this.resizeDropdownHeightTo(dropdownIsCollapsed ? _this.child_refs.activeTab.current : 0);\r\n                    return {\r\n                        dropdownIsCollapsed: !dropdownIsCollapsed,\r\n                        dropdownCurHeight: dropdownNewHeight\r\n                    };\r\n                });\r\n            }\r\n        };\r\n        _this.copyRefID = function (e) {\r\n            var tooltip = e.currentTarget;\r\n            _this.child_refs.refIDInputEl.current.select();\r\n            document.execCommand(\"copy\");\r\n            _this.child_refs.refIDInputEl.current.blur();\r\n            tooltip.textContent = 'Copied to clipboard';\r\n            setTimeout(function () {\r\n                _this.setState({ tooltipIsActive: false });\r\n                setTimeout(function () {\r\n                    tooltip.textContent = 'Copy';\r\n                }, 300);\r\n            }, 1500);\r\n        };\r\n        _this.handleTabToggle = function (e) {\r\n            var currentTab = _this.child_refs.activeTab.current, currentTabLink = e.currentTarget, activeTabName = currentTabLink.getAttribute('data-tab-name');\r\n            _this.setState({\r\n                dropdownCurHeight: _this.resizeDropdownHeightTo(currentTab),\r\n                activeTabName: activeTabName,\r\n                activeTabLinkName: activeTabName + \"-link\"\r\n            });\r\n        };\r\n        /**\r\n         * @param handleReferenceClick: Reference click handler; fetches recommended and required refs for clicked ref\r\n         */\r\n        _this.handleReferenceClick = function (e) {\r\n            //i.e. if link is clicked, prevent click event for ref\r\n            if (/extern-link/.test(e.target.className))\r\n                return;\r\n            var refID = e.currentTarget.dataset.id;\r\n            //first set loading to true to visualize fadeout\r\n            _this.setState({ refIsLoading: true });\r\n            setTimeout(function () {\r\n                var ref;\r\n                for (var _i = 0, _a = _this.state.payload.refs; _i < _a.length; _i++) {\r\n                    ref = _a[_i];\r\n                    if (ref.id === refID) {\r\n                        _this.setState({\r\n                            refID: ref.id,\r\n                            payload: ref\r\n                        });\r\n                        setTimeout(function () {\r\n                            _this.setState({\r\n                                refIsLoading: false,\r\n                                historyExists: true,\r\n                                dropdownCurHeight: _this.resizeDropdownHeightTo(_this.child_refs.activeTab.current)\r\n                            });\r\n                            //update history\r\n                            _this.history.push(Object.assign({}, _this.state));\r\n                            //delay till state payload is set before visualizing to avoid errors\r\n                            setTimeout(function () { return _this.visualizeGraph(); }, 200);\r\n                        }, 300);\r\n                        break;\r\n                    }\r\n                    else\r\n                        continue;\r\n                }\r\n            }, 300);\r\n        };\r\n        /**\r\n         * @param goBackInTime: history navigation (time traveller) function; handles going back one depth on click of 'back button'\r\n         */\r\n        _this.goBackInTime = function () {\r\n            var past, pastIndex = _this.history.length - 2, backInTime;\r\n            if (pastIndex >= 0 && _this.history[pastIndex])\r\n                _this.setState(function () {\r\n                    past = _this.history[pastIndex];\r\n                    backInTime = Object.assign({}, past);\r\n                    return backInTime;\r\n                });\r\n            else {\r\n                return _this.setState({ historyExists: false });\r\n            }\r\n            //remove/delete past future having travelled back in time\r\n            _this.history.pop();\r\n            //delay till state payload is set before visualizing to avoid errors\r\n            setTimeout(function () { return _this.visualizeGraph(); }, 200);\r\n        };\r\n        /**\r\n         * @param findNode: ReactDOM traverser function - querySelector; returns a DOM node\r\n         */\r\n        // findNode(parent: ReactInstance, childName?:string): any\r\n        // {\r\n        //   let DOMp: any = ReactDOM.findDOMNode(parent),\r\n        //       queryAll: HTMLElement[] = DOMp.querySelectorAll(childName);\r\n        //   if (childName)\r\n        //     return queryAll[1] ? queryAll : DOMp.querySelector(childName);\r\n        //   return DOMp;\r\n        // }\r\n        /**\r\n         * @param setGraphNodesAndEdges: gets and pushes graph nodes and edges to network for visualization\r\n         */\r\n        _this.setGraphNodesAndEdges = function (_ref) {\r\n            var themeCSS = _this.cssProps, ref = Object.assign({}, _ref), refHasParents = _ref.refs.length > 0 ? true : false, \r\n            //making a copy of refs (parents) to avoid modifying actual parents\r\n            parents = _ref.refs.map(function (parent) { return Object.assign({}, parent); }), colors = {\r\n                self: { bg: themeCSS.graphCurrentNodeBg, bdr: themeCSS.graphCurrentNodeBorderColor },\r\n                required: { bg: themeCSS.graphParentNodesBg, bdr: themeCSS.graphParentNodesBorderColor },\r\n                recommended: { bg: '#20dcff', bdr: '#10bcf0' },\r\n                alien: { bg: '#c0c0c0', bdr: '#b0b0b0' },\r\n                other: { bg: themeCSS.graphParentNodesBg, bdr: themeCSS.graphParentNodesBorderColor }\r\n            };\r\n            //returns object of node properties e.g. color, font, background, border etc.\r\n            var nodeProps = function (_ref) {\r\n                var color = {}, isCurrentRef = _ref.id === _this.state.refID;\r\n                color.bg = colors.other.bg;\r\n                color.bdr = colors.other.bdr;\r\n                return {\r\n                    font: {\r\n                        size: 14,\r\n                        face: 'Google Sans, Roboto Mono, Trebuchet MS',\r\n                        color: isCurrentRef ? colors.self.bdr : color.bdr,\r\n                        strokeWidth: 1,\r\n                        strokeColor: _this.cssProps.dropdownBg\r\n                    },\r\n                    color: {\r\n                        background: isCurrentRef ? colors.self.bg : color.bg,\r\n                        border: isCurrentRef ? colors.self.bdr : color.bdr,\r\n                        hover: {\r\n                            background: _this.cssProps.dropdownBg,\r\n                            border: isCurrentRef ? colors.self.bdr : color.bdr\r\n                        },\r\n                        highlight: {\r\n                            border: isCurrentRef ? colors.self.bdr : color.bdr,\r\n                            background: _this.cssProps.dropdownBg\r\n                        }\r\n                    },\r\n                    shape: 'dot',\r\n                    size: 16\r\n                };\r\n            };\r\n            var pushNodesAndEdges = function () {\r\n                // let parent: Payload;\r\n                for (var _i = 0, parents_1 = parents; _i < parents_1.length; _i++) {\r\n                    var parent_1 = parents_1[_i];\r\n                    var _nodeProps = nodeProps(parent_1), nodeExists = false;\r\n                    //prepare and push nodes for visualization. \r\n                    //PS: If parent (ref) doesn't already exist in network, push to network\r\n                    for (var _a = 0, _b = _this.graph.nodes; _a < _b.length; _a++) {\r\n                        var node = _b[_a];\r\n                        if (node.id.replace(/.*\\/(.*)/, '$1') === parent_1.id.replace(/.*\\/(.*)/, '$1')) {\r\n                            nodeExists = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!nodeExists) {\r\n                        _this.graph.nodes.unshift(Object.assign(tslib_1.__assign({ _id: parent_1.id, title: parent_1.data.title, label: parent_1.data.title.length > 10 ? parent_1.data.title.substr(0, 10).trim() + \"...\" : parent_1.data.title }, _nodeProps), parent_1));\r\n                        //extract hashID part of refID\r\n                        _this.graph.nodes[0].id = parent_1.id.replace(/.*\\/(.*)/, '$1');\r\n                    }\r\n                    //prepare and push edges for visualization\r\n                    _this.graph.edges.unshift({\r\n                        from: ref.id.replace(/.*\\/(.*)/, '$1'),\r\n                        to: parent_1.id.replace(/.*\\/(.*)/, '$1'),\r\n                        arrows: {\r\n                            to: {\r\n                                enabled: true,\r\n                                scaleFactor: 0.5\r\n                            }\r\n                        },\r\n                        length: 120,\r\n                        font: tslib_1.__assign({}, _nodeProps.font, { size: 9 }),\r\n                        color: {\r\n                            color: parent_1.ref_type === 'required' ? _this.cssProps.graphNetworkRequiredEdgeColor : _this.cssProps.graphNetworkRecommendedEdgeColor,\r\n                            highlight: parent_1.ref_type === 'required' ? _this.cssProps.graphNetworkRequiredEdgeColor : _this.cssProps.graphNetworkRecommendedEdgeColor,\r\n                            hover: parent_1.ref_type === 'required' ? _this.cssProps.graphNetworkRequiredEdgeColor : _this.cssProps.graphNetworkRecommendedEdgeColor\r\n                        }\r\n                    });\r\n                    //QUOTE OF THE CENTURY: \"To iterate is human, to recurse divine.\" - L. Peter Deutsch :D\r\n                    _this.setGraphNodesAndEdges(parent_1);\r\n                }\r\n            };\r\n            //i.e. if 'current' book (ref) has parents and itself has not yet been added to nodes (network), proceed to add\r\n            if (refHasParents && !_this.graph.nodes.find(function (node) { return node.id.replace(/.*\\/(.*)/, '$1') === ref.id.replace(/.*\\/(.*)/, '$1'); })) {\r\n                //first add current node (ref) to nodes before pushing other nodes to network\r\n                _this.graph.nodes.unshift(Object.assign(tslib_1.__assign({ _id: ref.id, label: ref.data.title.replace(/\\s(\\w+|\\d+)\\s(\\w+|\\d+)/, ' $1\\n$2') }, nodeProps(ref)), ref));\r\n                //extract hashID part of refID\r\n                _this.graph.nodes[0].id = ref.id.replace(/.*\\/(.*)/, '$1');\r\n                pushNodesAndEdges();\r\n            }\r\n            else if (refHasParents)\r\n                pushNodesAndEdges();\r\n        };\r\n        /**\r\n         * @param visualizeGraph: renders graph to DOM\r\n         */\r\n        _this.visualizeGraph = function () {\r\n            _this.graph = {\r\n                nodes: [],\r\n                edges: []\r\n            };\r\n            _this.setGraphNodesAndEdges(_this.state.payload);\r\n            //if no nodes exist (which implies no parent(s)), do not proceed to visualize graph to avoid errors\r\n            if (_this.graph.nodes.length < 1)\r\n                return;\r\n            //create an array with nodes\r\n            var nodes = new vis.DataSet(_this.graph.nodes), \r\n            //create an array with edges\r\n            edges = new vis.DataSet(_this.graph.edges), container = _this.child_refs.graph.current, \r\n            //set graph data\r\n            data = {\r\n                nodes: nodes,\r\n                edges: edges\r\n            }, \r\n            //set graph options\r\n            options = {\r\n                nodes: { borderWidth: 1.5 },\r\n                edges: {\r\n                    color: { inherit: false }\r\n                },\r\n                interaction: { hover: true }\r\n            }, \r\n            //create a network\r\n            network = new vis.Network(container, data, options), graphTooltip = _this.child_refs.graphTooltip.current;\r\n            var moveAndUpdateGraphTooltip = function (params) {\r\n                //'params.node' implies event is triggered by node-hover event while 'params.nodes[0]' implies event is triggered by node-click event\r\n                var label = !params.node ? params.nodes[0] : params.node, currentNode = _this.graph.nodes.find(function (node) { return label === node.id; }), authors = currentNode.data.authors, renderLink = \"url: <a \\n                          href='\" + currentNode.url + \"' \\n                          target='_blank'\\n                          rel='noopener noreferrer'\\n                          style='color: white;'>\" + currentNode.url + \"</a>\";\r\n                authors = authors.length > 1 ? authors[0] + \"...\" : authors;\r\n                graphTooltip.innerHTML =\r\n                    currentNode.data.title + \"<br />\\n        <i style='font-size: 11px;'>\\n          \" + (!params.node ? authors : '') + \"\\n        </i>\\n        <span style='font-size: 9px;'>\\n          \" + (!params.node ? currentNode._id : '') + \"\\n        </span>\\n        <i style='font-size: 9px;'>\" + (currentNode.url ? renderLink : '') + \"</i>\";\r\n                graphTooltip.style.left = Math.ceil(params.pointer.DOM.x) - 10 + \"px\";\r\n                graphTooltip.style.top = Math.ceil(params.pointer.DOM.y - (graphTooltip.offsetHeight - 10)) - 15 + \"px\";\r\n            };\r\n            //network nodes event listeners\r\n            network.on('selectNode', function (params) {\r\n                _this.setState({\r\n                    graphNodeIsHovered: true,\r\n                    graphNodeIsActive: true\r\n                });\r\n                console.log(params.event.center, '...', params.pointer);\r\n                moveAndUpdateGraphTooltip(params);\r\n            });\r\n            network.on('deselectNode', function () {\r\n                return _this.setState({\r\n                    graphNodeIsHovered: false,\r\n                    graphNodeIsActive: false\r\n                });\r\n            });\r\n            network.on('hoverNode', function (params) {\r\n                if (!_this.state.graphNodeIsActive) {\r\n                    _this.setState({ graphNodeIsHovered: true });\r\n                    moveAndUpdateGraphTooltip(params);\r\n                }\r\n            });\r\n            network.on('blurNode', function () { return _this.setState({\r\n                graphNodeIsHovered: _this.state.graphNodeIsActive ? true : false\r\n            }); });\r\n            network.on('dragStart', function () { return _this.setState({ graphNodeIsHovered: false }); });\r\n            network.on('dragEnd', function () { return _this.setState({ graphNodeIsHovered: false }); });\r\n            var graphIsZoomed = false, initialScale = _this.graph.nodes.length < 10 ? 0.85 : 0.55;\r\n            network.on('zoom', function () {\r\n                initialScale = network.getScale();\r\n                _this.setState({ graphNodeIsHovered: false });\r\n            });\r\n            network.on('doubleClick', function () {\r\n                if (!graphIsZoomed)\r\n                    network.moveTo({ scale: initialScale + 0.5 });\r\n                else\r\n                    network.moveTo({ scale: initialScale });\r\n                graphIsZoomed = !graphIsZoomed;\r\n            });\r\n            network.once('stabilized', function () { return network.moveTo({ scale: initialScale }); });\r\n        };\r\n        return _this;\r\n    }\r\n    /**\r\n     * @param resizeDropdownHeightTo: Returns height of current activeTab, or 0 if 'dropdownIsCollapsed'; used to compute and set height of dropdown menu\r\n     */\r\n    Widget.prototype.resizeDropdownHeightTo = function (activeTab, constHeight) {\r\n        if (constHeight === void 0) { constHeight = this.tabLinksWrapperheight; }\r\n        //i.e. if the argument, activeTab, is an element and not a number (0)... PS: Add 2px for border-bottom extension\r\n        return activeTab !== 0 ? (activeTab.offsetHeight + constHeight) + 2 : 0;\r\n    };\r\n    Widget.prototype.componentDidUpdate = function (p, nextProps) {\r\n        var activeTabName = nextProps.activeTabName, dropdownIsCollapsed = nextProps.dropdownIsCollapsed, dropdownCurHeight = this.resizeDropdownHeightTo(this.child_refs.activeTab.current);\r\n        if (!dropdownIsCollapsed)\r\n            if (activeTabName !== this.state.activeTabName)\r\n                this.setState({ dropdownCurHeight: dropdownCurHeight });\r\n    };\r\n    Widget.prototype.componentDidMount = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var activeTab, e_1, errMsg, appendDot, grammifiedErrMsg, googleFontCDN_1, awaitFontLoad;\r\n            var _this = this;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        //check what device user is running\r\n                        if (/(Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone)/i.test(window.navigator.userAgent))\r\n                            this.isViewedWithMobile = true;\r\n                        activeTab = this.child_refs.activeTab.current;\r\n                        this.setState({ refIsLoading: true });\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, 4, 5]);\r\n                        return [4 /*yield*/, fetch(\"http://\" + this.serverHostURL + \"/\" + this.state.refID)\r\n                                .then(function (response) { return response.json(); })\r\n                                .then(function (data) {\r\n                                //throw Error (i.e. do not proceed to try populating UI) if server returns an error [message]\r\n                                if (Object.keys(data).includes('error'))\r\n                                    throw new Error(data.error);\r\n                                else {\r\n                                    _this.setState({ payload: data });\r\n                                    //using another setState method here to update dropdown height to activeTab-height after it has been populated to avoid setting a height of 0 assuming it's done in the previous setState method\r\n                                    _this.setState({\r\n                                        errOccurred: false,\r\n                                        refIsLoading: false,\r\n                                        dropdownCurHeight: !_this.state.dropdownIsCollapsed ? _this.resizeDropdownHeightTo(activeTab) : _this.state.dropdownCurHeight\r\n                                    });\r\n                                }\r\n                                //delay till state payload is set before visualizing to avoid errors\r\n                                setTimeout(function () { return _this.visualizeGraph(); }, 200);\r\n                            })];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 3:\r\n                        e_1 = _a.sent();\r\n                        //TO-DO: delete this line in production\r\n                        alert('Hi, there. \\n\\nLemma Chain GUI could not establish connection with server, hence, got hard-coded refs instead for testing purposes.\\n\\n- Godspower');\r\n                        errMsg = String(e_1).replace(/(\\w+)?error:/i, '').trim(), appendDot = errMsg.substr(-1) !== '.' ? errMsg + \".\" : errMsg, grammifiedErrMsg = appendDot.charAt(0).toUpperCase() + appendDot.substr(1);\r\n                        this.setState({\r\n                            //TO-DO: delete this line in production\r\n                            payload: Get_HardCoded_Refs(),\r\n                            //TO-DO: uncomment this line in production\r\n                            // errOccurred: true,\r\n                            errMsg: \"\" + grammifiedErrMsg,\r\n                            refIsLoading: false\r\n                        });\r\n                        //HACK: The following setTimeout function is for a case where user toggles dropdown while Lemma Chain is still loading or fetching data and has not yet resolved\r\n                        //PS: Delay till after above state props is set in order to correctly set dropdown height\r\n                        setTimeout(function () {\r\n                            _this.setState({\r\n                                dropdownCurHeight: !_this.state.dropdownIsCollapsed ? _this.resizeDropdownHeightTo(activeTab) : _this.state.dropdownCurHeight\r\n                            });\r\n                            //TO-DO: delete this line in production\r\n                            _this.visualizeGraph();\r\n                        }, 200);\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        //hide clipboard tool-tip if anywhere else on page/document is clicked\r\n                        document.body.onclick = function (e) {\r\n                            if (!/tool-tip|ref-identifier/.test(e.target.className))\r\n                                _this.setState({ tooltipIsActive: false });\r\n                        };\r\n                        googleFontCDN_1 = document.getElementById('font-cdn');\r\n                        awaitFontLoad = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\r\n                            var heightRef, maxHeight;\r\n                            return tslib_1.__generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0:\r\n                                        _a.trys.push([0, , 2, 3]);\r\n                                        return [4 /*yield*/, fetch(\"\" + googleFontCDN_1.getAttribute('href'))];\r\n                                    case 1:\r\n                                        _a.sent();\r\n                                        return [3 /*break*/, 3];\r\n                                    case 2:\r\n                                        heightRef = this.child_refs.refItemWrapper.current.offsetHeight, maxHeight = heightRef * (widgetconfig.widgetMaxNumOfRefsDisplayableAtOnce || 3) + 2 + \"px\";\r\n                                        //using activeTab here instead of requiredTab since on component mount, requiredTab is activeTab, and also to prevent ref forwarding error\r\n                                        this.child_refs.activeTab.current.style.maxHeight = maxHeight;\r\n                                        this.child_refs.recommendedTab.current.style.maxHeight = maxHeight;\r\n                                        //HACK: unset history initial (first state) dropdown height from 0 to current activeTab height to prevent dropdown from resizing to 0 on click of back button assuming history index is at 0 (first state).\r\n                                        this.history[0].dropdownCurHeight = this.resizeDropdownHeightTo(this.child_refs.activeTab.current);\r\n                                        this.history[0].dropdownIsCollapsed = false;\r\n                                        return [7 /*endfinally*/];\r\n                                    case 3: return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        }); };\r\n                        awaitFontLoad();\r\n                        //update history\r\n                        this.history.push(Object.assign({}, this.state));\r\n                        return [7 /*endfinally*/];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Widget.prototype.render = function () {\r\n        var toggleBarItemsContextProviderValue = {\r\n            state: tslib_1.__assign({}, this.state),\r\n            copyRefID: this.copyRefID,\r\n            handleDropdownToggle: this.handleDropdownToggle,\r\n            refs: tslib_1.__assign({}, this.child_refs)\r\n        }, toggleBarLoaderContextProviderValue = {\r\n            refIsLoading: this.state.refIsLoading,\r\n            attributes: {\r\n                size: 8,\r\n                color: 'white',\r\n                type: 'minor'\r\n            }\r\n        }, tabLinksContextProviderValue = {\r\n            state: tslib_1.__assign({}, this.state),\r\n            goBackInTime: this.goBackInTime,\r\n            handleTabToggle: this.handleTabToggle,\r\n            ref: this.child_refs.activeTabLink\r\n        }, dropdownContextProviderValue = {\r\n            state: tslib_1.__assign({}, this.state),\r\n            ref: this.child_refs.dropdown\r\n        }, tabsContextProviderValue = {\r\n            state: tslib_1.__assign({}, this.state),\r\n            refs: tslib_1.__assign({}, this.child_refs),\r\n            handleReferenceClick: this.handleReferenceClick\r\n        }, loaderContextProviderValue = {\r\n            refIsLoading: this.state.refIsLoading,\r\n            attributes: {\r\n                size: 12,\r\n                color: getCSSProps().themeBg,\r\n                rider: this.state.payload.id ? 'Populating References...' : 'Loading References...',\r\n                type: 'major',\r\n                wrapperHeight: this.state.dropdownCurHeight - this.tabLinksWrapperheight\r\n            }\r\n        };\r\n        return (React.createElement(\"div\", { className: \"widget \" + (this.isViewedWithMobile ? 'isViewedWithMobile' : ''), style: { maxWidth: widgetconfig.widgetMaxWidth }, ref: this.widget },\r\n            React.createElement(ToggleBarItemsContext.Provider, { value: toggleBarItemsContextProviderValue },\r\n                React.createElement(LoaderContext.Provider, { value: toggleBarLoaderContextProviderValue },\r\n                    React.createElement(ToggleBarItems, null,\r\n                        React.createElement(Loader, null)))),\r\n            React.createElement(DropdownContext.Provider, { value: dropdownContextProviderValue },\r\n                React.createElement(TabLinksContext.Provider, { value: tabLinksContextProviderValue },\r\n                    React.createElement(TabsContext.Provider, { value: tabsContextProviderValue },\r\n                        React.createElement(LoaderContext.Provider, { value: loaderContextProviderValue },\r\n                            React.createElement(Dropdown, null,\r\n                                React.createElement(TabLinks, null),\r\n                                React.createElement(Tabs, null,\r\n                                    React.createElement(Loader, null)))))))));\r\n    };\r\n    return Widget;\r\n}(React.Component));\r\nexport default Widget;\r\n","references":["C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/node_modules/@types/react/index.d.ts","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/components/Dropdown.tsx","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/components/Loader.tsx","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/node_modules/@types/vis/index.d.ts","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/JSON_MockUp_Sample.tsx","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/ThemeCSS.tsx","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/widgetconfig.json","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/components/ToggleBarItems.tsx","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/components/TabLinks.tsx","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/components/Tabs.tsx","C:/Users/Power'f-GOD/rocketlaunchr/lemma-chain-react/react-app/src/context.tsx"]}
